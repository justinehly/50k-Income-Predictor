---
title: "Project2"
author: "Allen Miller"
date: "3/24/2021"
output: html_document
---

```{r libraries}
# Import Libraries
library(tidyverse)
library(stringr)
library(magrittr)
library(stats)
library(naniar)
library(GGally)
library(ggplot2)
library(directlabels)
library(caret)
library(ROSE)
library(dplyr)

```


```{r data import}
setwd("C:/Users/justi/Documents/GitHub/6372---50k-Income-Predictor/Data")
adult_info <- read.csv("adult.data.csv", header = TRUE)
# View(adult_info)
adult_test <- read.csv("adult.test.csv")
# set the clean set to the larger data set

# merge the data + test data to form one dataset for cleaning
tot_adult_info <- rbind(adult_info, adult_test)
str(tot_adult_info)
summary(tot_adult_info)

```

```{r clean data}
clean <- tot_adult_info

#Looking for Null Values - based on data description, NA = "?" or " ?"
sapply(clean, function(x) sum(sum(is.na(x)),
                              sum(x %in% "?"),
                              sum(x %in% " ?"))) 
# quite a few NA's
# workclass = 1836
# occupation = 1843
# native.country = 583

str(clean)
# looking at just the missing values
#missing <- clean %>% filter(occupation %in% " ?" |
#                              workclass %in% " ?" |
#                              native.country %in% " ?")
# View(missing)
# appears all the missing values for workclass are also missing for workclass - 
# let's set to "unknown and see if we can still predict

# replace " ?" with "Unknown"
clean$workclass <- replace(clean$workclass, clean$workclass %in% " ?", "Unknown")
clean$occupation <- replace(clean$occupation, clean$occupation %in% " ?", "Unknown")
clean$native.country <- replace(clean$native.country, clean$native.country %in% " ?", "Unknown")

#convert all chr to factors
clean[sapply(clean, is.character)] <- lapply(clean[sapply(clean, is.character)], as.factor)


levels(clean$workclass)
levels(clean$occupation)
levels(clean$native.country)
clean <- clean[,c(15,1:14)]

str(clean)
# something going on with class - will revisit shortly

summary(clean)
# data set will need to be balanced before any tests run
# 24,720 <=50k vs 7,841 >50k

# lots of zeros in the capital gains and losses columns, may be better to treat those as yes/no
zeros <- sapply(clean, function(x) sum(x == 0))
gainZeroPerc <- zeros[11]/dim(clean)[1]
gainZeroPerc # ~92% are 0's
lossZeroPerc <- zeros[12]/dim(clean)[1]
lossZeroPerc # ~95% are 0's

clean <- clean %>% mutate(capgain = case_when(capital.gain > 0 ~ "yes",
                                              TRUE ~ "no"),
                          caploss = case_when(capital.loss > 0 ~ "yes",
                                              TRUE ~ "no"))
# convert new columns to factor
clean[sapply(clean, is.character)] <- lapply(clean[sapply(clean, is.character)], as.factor)
str(clean)

# remove leading whitepsace from factors
factorCols <- names(clean)[vapply(clean, is.factor, logical(1))]
clean[,factorCols] <- lapply(clean[,factorCols], trimws)
clean[sapply(clean, is.character)] <- lapply(clean[sapply(clean, is.character)], as.factor)
str(clean)


# remove original capitcal gain/ loss cols
clean <- clean[,-c(12,13)]
names(clean)[1] <- "Income"

levels(clean$Income)
clean$Income <- as.factor(case_when(
  as.character(clean$Income) %in% c(">50K.", " >50K") ~ ">50K",
  as.character(clean$Income) %in% c("<=50K.", " <=50K") ~ "<=50K",
  TRUE ~ as.character(clean$Income)
))
# now the Income column is back to 2 levels


```



```{r EDA numeric variables}

attach(clean)

# check out the int variables
clean %>% select_if(is.integer) %>% 
  ggpairs(ggplot2::aes(color=clean$Income))
# not very good stories here, dont see any dependencies between the numberical values
```

```{r age}
#--- age ---#
t(aggregate(age~Income,data=clean,summary))
# Min Age <=50: 17/ >50: 19 
# Mean Age <=50: 37/ >50: 44
# Max Age = 90 for both
# people making >50 tend to be older, about 7yrs on average

ggplot(clean, aes(age, fill= Income)) + geom_bar(position="fill") +
  scale_x_continuous(breaks=seq(0,90, by = 10)) +
  labs(title="Age by Income") +
  theme_classic()
# quite a big of overlap between <=50 and >50 - may not be a good selector


ggplot(clean, aes(age, fill= Income)) + geom_boxplot() +
  scale_x_continuous(breaks=seq(0,90, by = 10)) + coord_flip() +
  labs(title="Age by Income") +
  theme_classic()
# quite a big of overlap between <=50 and >50 - may not be a good selector

``` 


```{r finlwgt}

ggplot(clean, aes(fnlwgt, fill= Income)) + geom_boxplot() +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="FinalWeight by Income",
       x ="Final Weight") + theme_classic() +
  coord_flip()
# this is a weighting metric, so not surprised that they boxplots are about the same
wgt <- glm(Income~fnlwgt, clean, family="binomial")
summary(wgt)
confint(wgt)
# with p-value = 0.08 we show that this variable is not statistically significant in 
# determining Income and a CI that includes 0!
```


```{r workclass}

workclassTable <- table(clean$workclass)
t(t(workclassTable))
propt <- t(t(prop.table(workclassTable)))
colnames(propt) <- "workclass proportions"
propt
p <- prop.table(table(clean$workclass, clean$Income))
p
t(aggregate(workclass~Income,data=clean,summary))
ggplot(clean, aes(workclass, fill= Income)) + 
  geom_bar() +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title = "WorkClass by Income") 
summary(clean$workclass)

# Private have the bulk of the entries ~ 70%
# unpaid people make up less than .001% 
sum(p[c(1,2,7)])*100 # = 13% # gov workers
# all government workers make up a combined 13% maybe we should combine those???
# self employed combined make up 10% 3% inc, 7% not-inc
# this variable may be useful as well - self employed are favored to make >50k
wc <- glm(Income~workclass, clean, family='binomial')
summary(wc)
confint(wc)
# never worked, without-pay arent stat sig, let's combine them now
clean$workclass <- as.factor(case_when(
  as.character(clean$workclass) %in% c("Never-worked", "Without-pay") ~ "Unpaid",
  TRUE ~ as.character(clean$workclass)
))
# unpaid still not sig, so lets merge it with unknown
# also looking over proporrtions table, we can merge the government jobs together
clean$workclass <- as.factor(case_when(
  as.character(clean$workclass) %in% c("Unknown", "Unpaid") ~ "Unknown/Unpaid",
  as.character(clean$workclass) %in% c("Local-gov", "State-gov", "Federal-gov") ~ "Gov't",
  TRUE ~ as.character(clean$workclass)
))
# rerun our tables
workclassTable <- table(clean$workclass)
propt <- t(t(prop.table(workclassTable)))
colnames(propt) <- "workclass proportions"
propt
p <- prop.table(table(clean$workclass, clean$Income))
p
t(aggregate(workclass~Income,data=clean,summary))
wc <- glm(Income~workclass, clean, family='binomial')
summary(wc)
confint(wc)
# this looks a lot better
```


```{r occupation}

# see how workclass changes affected occupation

t(aggregate(occupation~workclass,data=clean,summary))
t(prop.table(table(clean$workclass, clean$occupation)))
# seems similar to workclass
ggplot(clean, aes(x=workclass, fill= occupation)) + 
  geom_bar() +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Workclass by Occupation")
# just plot occupation totals
ggplot(clean, aes(x=occupation, fill = workclass)) + 
  geom_bar() +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Occupation Totals")
ggplot(clean, aes(x=occupation, fill = Income)) + 
  geom_bar() +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Occupation Totals")
occ.glm <- glm(Income~occupation, data=clean, family='binomial')
summary(occ.glm)
confint(occ.glm)
# looks like we can combine armed forces with another occupation since there are only 9 of them
# based on my tables protective.service seems like a good fit

clean$occupation <- as.factor(case_when(
  as.character(clean$occupation) %in% c("Armed-Forces", "Protective-serv") ~ "ArmForc/ ProtSvc",
  TRUE ~ as.character(clean$occupation)
))
# rerun glm 
occ.glm <- glm(Income~occupation, data=clean, family='binomial')
summary(occ.glm)
confint(occ.glm)
# now when we re-run the glm statement, Farming-fishing and Other-service are insig
#                   Estimate Std. Error z value Pr(>|z|) 
# Farming-fishing   -0.17196    0.11006  -1.563  0.11817 - merge with
# Machine-op-inspct -0.08516    0.08276  -1.029  0.30349 - merge with Other-service

# Exec-managerial, Prof-sepcialty look good for making >50
```


```{r education and education.num}
#--- education ---#
t(aggregate(education~Income,data=clean,summary))
ggplot(clean, aes(education, fill= Income)) + geom_bar(position="fill") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Education by Income") + theme_classic()
# this one favors more educated people to make >50k

#--- education.num---#
t(aggregate(education.num~Income,data=clean,summary))
# this may work better with education.num as a factor, but more education = more $$$
ggplot(clean, aes(education.num, fill= Income)) + geom_bar(position="fill") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Education Years by Income") + theme_classic()
# somewhat redundant with education, just in a continuous format

```


```{r marital.status and relationship}
t(aggregate(marital.status~Income,data=clean,summary))
# married people have the better chances of earning >50k
ggplot(clean, aes(x=marital.status, fill= Income)) + 
  geom_bar(position="fill") +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Marital Status by Income")
# Married-AF-spouse (armed forces) and Married-civ-spouse (civilian) have highest potential to make >50k 
#--- combining married-AF with married-civ since there are only 23 married-AF


clean$marital.status <- as.factor(case_when(
  as.character(clean$marital.status) %in% c("Married-AF-spouse", 
                        "Married-civ-spouse") ~ "Married-spouse",
  TRUE ~ as.character(clean$marital.status)))
levels(clean$marital.status)


test$marital.status <- as.factor(case_when(
  as.character(test$marital.status) %in% c("Married-AF-spouse", 
                        "Married-civ-spouse") ~ "Married-spouse",
  TRUE ~ as.character(test$marital.status)))
levels(test$marital.status)

# married people have the better chances of earning >50k

t(aggregate(relationship~Income,data=clean,summary))
ggplot(clean, aes(relationship, fill= Income)) + geom_bar(position="fill") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Relationship by Income") + theme_classic()
# redunant to marital.status where married people have highest potential to >50

t(aggregate(marital.status~relationship,data=clean,summary))
ggplot(clean, aes(x=relationship, fill= marital.status)) + 
  geom_bar(stat="count") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Relationship by Marital Status")

t(aggregate(marital.status~sex+Income,data=clean,summary))
ggplot(clean, aes(relationship, fill= Income)) + geom_bar(position="fill") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Relationship by Income") + theme_classic()
# redunant to marital.status where married people have highest potential to >50

```


```{r race, native country}
t(aggregate(race~Income,data=clean,summary))
ggplot(clean, aes(race, fill= Income)) + geom_bar(position="fill") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Race by Income") + theme_classic()
# none of these seems to point to making over 50

t(aggregate(native.country~Income,data=clean,summary))
ggplot(clean, aes(native.country, fill= Income)) + geom_bar(position="fill") +
   theme_classic() + theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Native Country by Income")
# quite a few of these pop, may be very useful

```
 
 
```{r capgain/ caploss}
t(aggregate(capgain~Income,data=clean,summary))
ggplot(clean, aes(capgain, fill= Income)) + geom_bar(position="fill") +
  labs(title="Has Capital Grains by Income") + theme_classic()
  #theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0))
# people with capital gains tend to make more than 50

t(aggregate(caploss~Income,data=clean,summary))
ggplot(clean, aes(caploss, fill= Income)) + geom_bar(position="fill") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  labs(title="Has Campital Loss by Income") + theme_classic()
# people with capital.loss also have tend to make >50

```


```{r hours/week}
t(aggregate(hours.per.week~Income,data=clean,summary))
ggplot(clean, aes(hours.per.week, fill= Income)) + geom_bar(position="fill") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  scale_x_continuous(breaks=seq(0,100, by = 10)) +
  labs(title="Hours Per Week by Income",
       x = "Hours Worked Per Week") + theme_classic()
# this maybe a decent predictor since we can see some separation between hours and over/under 50k

ggplot(clean, aes(x=occupation,y=hours.per.week, fill= Income)) + geom_bar(stat="identity") +
  theme(axis.text.x = element_text(angle = 270, vjust = 0, hjust = 0)) +
  scale_y_continuous(breaks=seq(0,100, by = 10)) +
  labs(title="Hours Per Week by Income",
       x = "Occupation",
       y = "Hours/Week") 

detach(clean)
```


```{r split clean df into train/ test 2/3 vs 1/3}

set.seed(123)
smp.size <- floor( (nrow(clean)/3) * 2)
train.ind <- sample(seq_len(nrow(clean)), size=smp.size)
train <- clean[train.ind,]
test <- clean[-train.ind,]


```


```{r balance training dataset}
# instruction from: https://www.analyticsvidhya.com/blog/2016/03/practical-guide-deal-imbalanced-classification-problems/
# using ROSE library

# recheck table
table(train$Income)

# Income distribution
prop.table(table(train$Income))
prop.table(table(test$Income))

library(rpart)
# use decision tree to check for prediction accuracy on raw data
glmimb <- glm(Income~., data=train, family='binomial')
pred.glmimb <- predict(glmimb, newdata = test)

accuracy.meas(test$Income, pred.glmimb[,2])
# threshold = 0.5
# not very good numbers 
# precision = 0.679 {precision of prediction}
# recall = 0.546 {recall of the prediction}
# F = 0.303 {average between precision and recall}

roc.curve(test$Income, pred.treeimb[,2], plotit = T)
# AUC = 0.826 which isn't all the bad

# over sampling
data_balanced_over <- ovun.sample(Income~., data=clean, method = "over", N = 24720 * 2, seed = 123)$data
table(data_balanced_over$Income)
# data is now balance between <=50k and >50k

data_balanced_under <- ovun.sample(Income~., data=clean, method = "under", N = 7841 * 2, seed = 123)$data
table(data_balanced_under$Income)

data_balanced_both <- ovun.sample(Income~., data=clean, method = "both", p=0.5, seed = 123)$data
table(data_balanced_both$Income)

data.rose <- ROSE(Income~., data=clean, seed = 123)$data
table(data.rose$Income)

# build decision trees to evaluate accuracy
tree.rose <- rpart(Income~., data = data.rose)
tree.over <- rpart(Income~., data = data_balanced_over)
tree.under <- rpart(Income~., data = data_balanced_under)
tree.both <- rpart(Income~., data = data_balanced_both)

# make predictions
pred.tree.rose <- predict(tree.rose, newdata = test)
pred.tree.over <- predict(tree.over, newdata = test)
pred.tree.under <- predict(tree.under, newdata = test)
pred.tree.both <- predict(tree.both, newdata = test)

#AUC Rose
roc.curve(test$Income, pred.tree.rose[,2], add.roc = F, col = "red")

#AUC Over
roc.curve(test$Income, pred.tree.over[,2], add.roc = T, col = "blue")

#AUC Under
roc.curve(test$Income, pred.tree.under[,2], add.roc = T, col = "green")

#AUC Both
roc.curve(test$Income, pred.tree.both[,2], add.roc = T, col = "black")

pta <- accuracy.meas(test$Income, pred.tree.rose[,2])
pto <- accuracy.meas(test$Income, pred.tree.over[,2])
ptu <- accuracy.meas(test$Income, pred.tree.under[,2])
ptb <- accuracy.meas(test$Income, pred.tree.both[,2])

tree <- c("Rose", "Over", "Under", "Both")
precision <- as.numeric(unlist(c(pta[3], pto[3], ptu[3], ptb[3])))
recall <- as.numeric(unlist(c(pta[4], pto[4], ptu[4], ptb[4])))
F <- as.numeric(unlist(F <- c(pta[5], pto[5], ptu[5], ptb[5])))

# put all the accuract measures into 1 dataframe
accuracyDF <- data.frame(tree, precision, recall, F)
accuracyDF
# over or under perform the same, I prefer the larger dataset = over


```